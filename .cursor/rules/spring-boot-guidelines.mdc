# Spring Boot Microservices Development Guidelines

## ğŸ¯ Core Principles
- **Clean Architecture**: Separate concerns (Controller â†’ Service â†’ Repository)
- **Microservices First**: Design for service independence and scalability
- **Event-Driven**: Use RabbitMQ for loose coupling between services
- **Firebase Auth**: Leverage Firebase for authentication, not Spring Security
- **Docker Ready**: All services should be containerizable

## ğŸ—ï¸ Project Structure
```
service-name/
â”œâ”€â”€ src/main/java/com/yuzao/platform/servicename/
â”‚   â”œâ”€â”€ controller/     # REST API endpoints
â”‚   â”œâ”€â”€ service/        # Business logic
â”‚   â”œâ”€â”€ repository/     # Data access
â”‚   â”œâ”€â”€ entity/         # JPA entities
â”‚   â”œâ”€â”€ dto/           # Request/Response objects
â”‚   â”œâ”€â”€ event/         # RabbitMQ events
â”‚   â”œâ”€â”€ listener/      # Event listeners
â”‚   â””â”€â”€ config/        # Configuration classes
â”œâ”€â”€ src/main/resources/
â”‚   â””â”€â”€ application.yml
â”œâ”€â”€ Dockerfile
â””â”€â”€ pom.xml
```

## ğŸ”§ Naming Conventions
- **Controllers**: `*Controller` (UserController)
- **Services**: `*Service` (UserService)
- **Repositories**: `*Repository` (UserRepository)
- **Entities**: `*` (User, Booking)
- **DTOs**: `*Dto`, `*Request`, `*Response` (UserDto, CreateUserRequest)
- **Events**: `*Event` (UserCreatedEvent)
- **Listeners**: `*EventListener` (UserCreatedEventListener)

## ğŸ—„ï¸ Database Patterns
- **Use JPA entities** with proper annotations
- **Include audit fields**: `createdAt`, `updatedAt`, `createdBy`, `updatedBy`
- **Use BaseEntity** for common fields
- **Link to Firebase**: Include `firebaseUid` field in User entities

## ğŸ” Authentication Strategy
- **Firebase handles auth** - no Spring Security needed
- **API Gateway validates tokens** and adds user info to headers
- **Services read user context** from headers (`X-User-ID`, `X-User-Email`)

## ğŸ“¡ API Design
- **RESTful endpoints** with proper HTTP methods
- **Use ApiResponse<T>** wrapper for consistent responses
- **OpenAPI annotations** for documentation
- **Validation** with `@Valid` and Bean Validation

## ğŸ° Event-Driven Patterns
- **Publish events** for important state changes
- **Use RabbitMQ** for service communication
- **Event classes** extend BaseEvent with eventId, timestamp, source
- **Listeners** handle events asynchronously

## ğŸ§ª Testing Approach
- **Unit tests** with Mockito for business logic
- **Integration tests** for API endpoints
- **Test-driven development** when possible
- **Use TestRestTemplate** for API testing

## ğŸ³ Containerization
- **Multi-stage Dockerfiles** for optimized images
- **Health checks** in Docker Compose
- **Environment variables** for configuration
- **Non-root users** for security

## ğŸ“ Code Quality
- **Meaningful names** - self-documenting code
- **Small methods** - max 20-30 lines
- **Single responsibility** - one reason to change
- **Fail fast** - validate early, throw exceptions immediately
- **Use Optional** for nullable returns

## ğŸš€ Performance
- **Database indexes** on frequently queried fields
- **Connection pooling** with HikariCP
- **Caching** with Spring Cache
- **Async processing** for non-critical operations

## ğŸ”§ Configuration
- **Environment-based** configuration
- **Externalized properties** for different environments
- **Service discovery** with Eureka
- **Health checks** with Spring Boot Actuator

## ğŸ“Š Monitoring
- **Spring Boot Actuator** for health and metrics
- **Structured logging** with proper log levels
- **Error tracking** with proper exception handling
- **Performance metrics** for critical operations

## ğŸ¯ Key Success Factors
1. **Service Independence** - Each service should be deployable independently
2. **Loose Coupling** - Use events for service communication
3. **Data Consistency** - Handle eventual consistency in distributed systems
4. **Error Resilience** - Implement circuit breakers and retry mechanisms
5. **Observability** - Log, monitor, and trace service interactions

## ğŸ’¡ Best Practices
- **Start simple** - Add complexity only when needed
- **Design for failure** - Services should handle other service failures gracefully
- **Version APIs** - Use versioning for API evolution
- **Document everything** - APIs, events, configuration
- **Security first** - Validate all inputs, sanitize outputs

This guide ensures scalable, maintainable microservices that can grow with your platform! ğŸš€
