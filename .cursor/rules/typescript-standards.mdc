# TypeScript Development Standards

## Core Patterns

### Interface Patterns
```typescript
// ✅ Good: Specific types with proper structure
interface User {
  id: string;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'moderator';
  createdAt: Date;
  profile?: {
    avatar?: string;
    bio?: string;
  };
}

// ❌ Bad: Using 'any'
const user: any = { /* ... */ };
```

### API Response Types
```typescript
interface ApiResponse<T> {
  data: T;
  message: string;
  success: boolean;
  timestamp: string;
}

type UserResponse = ApiResponse<User>;
type ErrorResponse = ApiResponse<null>;
```

### State Management Types
```typescript
// ✅ Good: Use descriptive names and proper typing
const [isLoading, setIsLoading] = useState<boolean>(false);
const [users, setUsers] = useState<User[]>([]);
const [error, setError] = useState<string | null>(null);
```

### Function Types
```typescript
// ✅ Good: Explicit function types
type UserUpdateHandler = (user: User) => Promise<void>;
type ValidationFunction = (value: string) => boolean;
```

### Utility Types
```typescript
// ✅ Good: Use TypeScript utility types
type UserWithoutId = Omit<User, 'id'>;
type UserUpdateData = Partial<User>;
type UserKeys = keyof User;

// ✅ Good: Custom utility types
type AsyncState<T> = {
  data: T | null;
  loading: boolean;
  error: string | null;
};
```

### Component Props Types
```typescript
interface ButtonProps {
  children: React.ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  onClick?: () => void;
  className?: string;
}
```

### Error Handling Types
```typescript
class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public code?: string
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };
```

## Key Principles
- **Always use specific types** instead of `any`
- **Use union types** for simple cases, enums for complex ones
- **Define interfaces for all props** and API responses
- **Use utility types** for common transformations
- **Implement proper error handling** with custom error types

**Why**: Strong typing prevents runtime errors, improves IDE support, and ensures predictable data handling.
